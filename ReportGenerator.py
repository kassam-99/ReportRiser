import csv
import datetime
import json
import os
import platform
from typing import List, Dict, Optional

class Report_Generator:
    def __init__(self):
        """Initialize default filenames for reports."""
        self.default_name_csv = 'ReportCSV'
        self.default_name_txt = 'ReportText'
        self.default_name_json = 'ReportJSON'

    def _get_unique_filename(self, filename: str) -> str:
        """
        Generates a unique filename by appending numbers if the file exists.

        Args:
            filename: The base filename to check.

        Returns:
            A unique filename that does not exist.
        """
        base, ext = os.path.splitext(filename)
        counter = 1
        new_filename = filename
        while os.path.exists(new_filename):
            new_filename = f"{base}({counter}){ext}"
            counter += 1
        return new_filename

    def _get_user_filename(self, default_name: str, extension: str, interactive: bool = True) -> str:
        """
        Gets a filename from user input or uses default in non-interactive mode.

        Args:
            default_name: The default filename to use if none provided.
            extension: The file extension to append if missing.
            interactive: Whether to prompt for user input (default: True).

        Returns:
            The chosen filename with extension.
        """
        filename = default_name
        if interactive:
            try:
                user_input = input(f"[>] Enter desired filename for the report (or press Enter for default: {default_name}): ")
                if user_input:
                    filename = user_input
            except EOFError:
                pass  # Use default in non-interactive environments
        if not filename.endswith(extension):
            filename += extension
        return filename

    def _add_metadata(self, file) -> None:
        """
        Adds metadata to the report file.

        Args:
            file: The file object to write metadata to.

        Returns:
            None
        """
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        file.write(f"Report generated on: {timestamp}\n")
        file.write(f"Generated by: {os.getlogin()}\n")
        try:
            file.write(f"Hostname: {platform.node()}\n")
            file.write(f"OS: {platform.system()} {platform.release()}\n")
        except AttributeError:
            file.write("Hostname: Unknown\n")
            file.write("OS: Unknown\n")
        file.write("\n=============================\n\n")

    def CSV_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, interactive: bool = True) -> None:
        """
        Generates a CSV report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            interactive: Whether to prompt for filename (default: True).

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            if not Data:
                print("[!] No discovered data to write. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_csv, '.csv', interactive)
            filename = self._get_unique_filename(filename)
            all_fieldnames = set()
            for fdata in Data:
                all_fieldnames.update(fdata.keys())
            all_fieldnames = sorted(all_fieldnames)

            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=all_fieldnames)
                writer.writeheader()
                print("[>] Writing data to CSV file...")
                for fdata in Data:
                    writer.writerow(fdata)
                print("[>] Data writing completed.")

            full_path = os.path.abspath(filename)
            print(f"[+] Report generated successfully in CSV format: {filename}")
            print(f"[+] Total records written: {len(Data)}")
            print(f"[+] Path of {filename}: {full_path}")

        except Exception as e:
            print(f"[!] Error generating CSV report: {e}")
            print(f"[!] Detailed Error: {e.__class__.__name__} - {e}")

    def TXT_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, interactive: bool = True) -> None:
        """
        Generates a TXT report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            interactive: Whether to prompt for filename (default: True).

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            if not Data:
                print("[!] No discovered data to write. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_txt, '.txt', interactive)
            filename = self._get_unique_filename(filename)
            with open(filename, 'w', encoding='utf-8') as txtfile:
                self._add_metadata(txtfile)
                print("[>] Writing data to TXT file...")
                for index, fdata in enumerate(Data, start=1):
                    txtfile.write(f"Record {index}\n")
                    for key, value in fdata.items():
                        txtfile.write(f"{key}: {value}\n")
                    txtfile.write("\n-----------------------------\n")
                print("[>] Data writing completed.")

            full_path = os.path.abspath(filename)
            print(f"[+] Report generated successfully in TXT format: {filename}")
            print(f"[+] Total records written: {len(Data)}")
            print(f"[+] Path of {filename}: {full_path}")

        except Exception as e:
            print(f"[!] Error generating TXT report: {e}")
            print(f"[!] Detailed Error: {e.__class__.__name__} - {e}")

    def JSON_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, interactive: bool = True) -> None:
        """
        Generates a JSON report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            interactive: Whether to prompt for filename (default: True).

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            if not Data:
                print("[!] No scan data to write. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_json, '.json', interactive)
            filename = self._get_unique_filename(filename)
            with open(filename, 'w', encoding='utf-8') as jsonfile:
                print("[>] Writing data to JSON file...")
                metadata = {
                    "generated_on": datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    "generated_by": os.getlogin(),
                    "hostname": platform.node() or "Unknown",
                    "os": f"{platform.system()} {platform.release()}" or "Unknown"
                }
                output = {"metadata": metadata, "data": Data}
                json.dump(output, jsonfile, indent=4)
                print("[>] Data writing completed.")

            full_path = os.path.abspath(filename)
            print(f"[+] Report generated successfully in JSON format: {filename}")
            print(f"[+] Total records written: {len(Data)}")
            print(f"[+] Path of {filename}: {full_path}")

        except Exception as e:
            print(f"[!] Error generating JSON report: {e}")
            print(f"[!] Detailed Error: {e.__class__.__name__} - {e}")

if __name__ == "__main__":
    # Example usage
    generator = Report_Generator()
    sample_data = [{"Name": "John", "Age": 30}, {"Name": "Jane", "Age": 25}]
    generator.CSV_GenerateReport(sample_data, interactive=False)
    generator.TXT_GenerateReport(sample_data, interactive=False)
    generator.JSON_GenerateReport(sample_data, interactive=False)