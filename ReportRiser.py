import csv
import datetime
import json
import os
import platform
import logging
import xml.etree.ElementTree as ET
from xml.dom import minidom
from typing import List, Dict, Optional, Callable
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib import colors

class Report_Generator:
    def __init__(self):
        """Initialize default filenames and logging for reports."""
        self.default_name_csv = 'ReportCSV'
        self.default_name_txt = 'ReportText'
        self.default_name_json = 'ReportJSON'
        self.default_name_xml = 'ReportXML'
        self.default_name_html = 'ReportHTML'
        self.default_name_md = 'ReportMD'
        self.default_name_pdf = 'ReportPDF'
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler('report_generator.log')
            ]
        )
        self.logger = logging.getLogger(__name__)

    def _get_unique_filename(self, filename: str, output_dir: Optional[str] = None) -> str:
        """
        Generates a unique filename by appending numbers if the file exists.

        Args:
            filename: The base filename to check.
            output_dir: Optional directory to save the file.

        Returns:
            A unique filename that does not exist.
        """
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
            filename = os.path.join(output_dir, filename)
        base, ext = os.path.splitext(filename)
        counter = 1
        new_filename = filename
        while os.path.exists(new_filename):
            new_filename = f"{base}({counter}){ext}"
            counter += 1
        return new_filename

    def _get_user_filename(self, default_name: str, extension: str, interactive: bool = True) -> str:
        """
        Gets a filename from user input or uses default in non-interactive mode.

        Args:
            default_name: The default filename to use if none provided.
            extension: The file extension to append if missing.
            interactive: Whether to prompt for user input (default: True).

        Returns:
            The chosen filename with extension.
        """
        filename = default_name
        if interactive:
            try:
                user_input = input(f"[>] Enter desired filename for the report (or press Enter for default: {default_name}): ")
                if user_input:
                    filename = user_input
            except EOFError:
                pass
        if not filename.endswith(extension):
            filename += extension
        return filename

    def _add_metadata(self, file, custom_metadata: Optional[Dict] = None) -> None:
        """
        Adds metadata to the report file.

        Args:
            file: The file object to write metadata to.
            custom_metadata: Optional dictionary of custom metadata.

        Returns:
            None
        """
        timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        file.write(f"Report generated on: {timestamp}\n")
        file.write(f"Generated by: {os.getlogin()}\n")
        try:
            file.write(f"Hostname: {platform.node()}\n")
            file.write(f"OS: {platform.system()} {platform.release()}\n")
        except AttributeError:
            file.write("Hostname: Unknown\n")
            file.write("OS: Unknown\n")
        if custom_metadata:
            for key, value in custom_metadata.items():
                file.write(f"{key}: {value}\n")
        file.write("\n=============================\n\n")

    def _process_data(self, Data: List[Dict], filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> List[Dict]:
        """
        Processes data by applying filtering and sorting.

        Args:
            Data: Input data as a list of dictionaries.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            Processed data as a list of dictionaries.
        """
        processed_data = Data
        if filter_func:
            processed_data = [d for d in processed_data if filter_func(d)]
        if sort_key:
            processed_data = sorted(processed_data, key=sort_key)
        return processed_data

    def CSV_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates a CSV report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No discovered data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_csv, '.csv', interactive)
            filename = self._get_unique_filename(filename, output_dir)
            all_fieldnames = set()
            for fdata in processed_data:
                all_fieldnames.update(fdata.keys())
            all_fieldnames = sorted(all_fieldnames)

            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=all_fieldnames)
                writer.writeheader()
                self.logger.info("Writing data to CSV file...")
                for fdata in processed_data:
                    writer.writerow(fdata)
                self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in CSV format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating CSV report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

    def TXT_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates a TXT report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No discovered data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_txt, '.txt', interactive)
            filename = self._get_unique_filename(filename, output_dir)
            with open(filename, 'w', encoding='utf-8') as txtfile:
                self._add_metadata(txtfile, custom_metadata)
                self.logger.info("Writing data to TXT file...")
                for index, fdata in enumerate(processed_data, start=1):
                    txtfile.write(f"Record {index}\n")
                    for key, value in fdata.items():
                        txtfile.write(f"{key}: {value}\n")
                    txtfile.write("\n-----------------------------\n")
                self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in TXT format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating TXT report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

    def JSON_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates a JSON report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No scan data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_json, '.json', interactive)
            filename = self._get_unique_filename(filename, output_dir)
            with open(filename, 'w', encoding='utf-8') as jsonfile:
                self.logger.info("Writing data to JSON file...")
                metadata = {
                    "generated_on": datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    "generated_by": os.getlogin(),
                    "hostname": platform.node() or "Unknown",
                    "os": f"{platform.system()} {platform.release()}" or "Unknown"
                }
                if custom_metadata:
                    metadata.update(custom_metadata)
                output = {"metadata": metadata, "data": processed_data}
                json.dump(output, jsonfile, indent=4)
                self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in JSON format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating JSON report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

    def XML_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates an XML report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No discovered data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_xml, '.xml', interactive)
            filename = self._get_unique_filename(filename, output_dir)

            root = ET.Element("report")
            metadata = ET.SubElement(root, "metadata")
            ET.SubElement(metadata, "generated_on").text = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            ET.SubElement(metadata, "generated_by").text = os.getlogin()
            ET.SubElement(metadata, "hostname").text = platform.node() or "Unknown"
            ET.SubElement(metadata, "os").text = f"{platform.system()} {platform.release()}" or "Unknown"
            if custom_metadata:
                for key, value in custom_metadata.items():
                    ET.SubElement(metadata, key.lower().replace(" ", "_")).text = str(value)

            data = ET.SubElement(root, "data")
            for idx, fdata in enumerate(processed_data, start=1):
                record = ET.SubElement(data, f"record_{idx}")
                for key, value in fdata.items():
                    ET.SubElement(record, key.lower().replace(" ", "_")).text = str(value)

            self.logger.info("Writing data to XML file...")
            xmlstr = minidom.parseString(ET.tostring(root)).toprettyxml(indent="    ")
            with open(filename, 'w', encoding='utf-8') as xmlfile:
                xmlfile.write(xmlstr)
            self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in XML format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating XML report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

    def HTML_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates an HTML report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No discovered data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_html, '.html', interactive)
            filename = self._get_unique_filename(filename, output_dir)

            self.logger.info("Writing data to HTML file...")
            with open(filename, 'w', encoding='utf-8') as htmlfile:
                htmlfile.write(f"""<!DOCTYPE html>
<html>
<head>
    <title>Report</title>
    <style>
        table {{ border-collapse: collapse; width: 100%; }}
        th, td {{ border: 1px solid black; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
        .metadata {{ margin-bottom: 20px; }}
    </style>
</head>
<body>
    <div class="metadata">
        <h2>Metadata</h2>
        <p><strong>Generated on:</strong> {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <p><strong>Generated by:</strong> {os.getlogin()}</p>
        <p><strong>Hostname:</strong> {platform.node() or "Unknown"}</p>
        <p><strong>OS:</strong> {platform.system()} {platform.release() or "Unknown"}</p>""")
                if custom_metadata:
                    for key, value in custom_metadata.items():
                        htmlfile.write(f"        <p><strong>{key}:</strong> {value}</p>\n")
                htmlfile.write("    </div>\n    <h2>Data</h2>\n    <table>\n        <tr>")
                all_fieldnames = sorted(set().union(*(fdata.keys() for fdata in processed_data)))
                for key in all_fieldnames:
                    htmlfile.write(f"<th>{key}</th>")
                htmlfile.write("</tr>\n")
                for fdata in processed_data:
                    htmlfile.write("        <tr>")
                    for key in all_fieldnames:
                        htmlfile.write(f"<td>{fdata.get(key, '')}</td>")
                    htmlfile.write("</tr>\n")
                htmlfile.write("    </table>\n</body>\n</html>")
            self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in HTML format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating HTML report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

    def MD_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates a Markdown report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No discovered data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_md, '.md', interactive)
            filename = self._get_unique_filename(filename, output_dir)

            self.logger.info("Writing data to Markdown file...")
            with open(filename, 'w', encoding='utf-8') as mdfile:
                mdfile.write("# Report\n\n## Metadata\n\n")
                mdfile.write(f"- **Generated on**: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                mdfile.write(f"- **Generated by**: {os.getlogin()}\n")
                mdfile.write(f"- **Hostname**: {platform.node() or 'Unknown'}\n")
                mdfile.write(f"- **OS**: {platform.system()} {platform.release() or 'Unknown'}\n")
                if custom_metadata:
                    for key, value in custom_metadata.items():
                        mdfile.write(f"- **{key}**: {value}\n")
                mdfile.write("\n## Data\n\n")
                all_fieldnames = sorted(set().union(*(fdata.keys() for fdata in processed_data)))
                mdfile.write("| " + " | ".join(all_fieldnames) + " |\n")
                mdfile.write("| " + " | ".join(["---" for _ in all_fieldnames]) + " |\n")
                for fdata in processed_data:
                    mdfile.write("| " + " | ".join(str(fdata.get(key, '')) for key in all_fieldnames) + " |\n")
            self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in Markdown format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating Markdown report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

    def PDF_GenerateReport(self, Data: List[Dict], filename: Optional[str] = None, output_dir: Optional[str] = None, interactive: bool = True, custom_metadata: Optional[Dict] = None, filter_func: Optional[Callable] = None, sort_key: Optional[Callable] = None) -> None:
        """
        Generates a PDF report from the provided data.

        Args:
            Data: A list of dictionaries containing the data to write.
            filename: Optional; the name of the output file. If None, prompts the user.
            output_dir: Optional; directory to save the file.
            interactive: Whether to prompt for filename (default: True).
            custom_metadata: Optional dictionary of custom metadata.
            filter_func: Optional function to filter data.
            sort_key: Optional function to sort data.

        Returns:
            None
        """
        try:
            if not isinstance(Data, list) or not all(isinstance(item, dict) for item in Data):
                raise ValueError("Data must be a list of dictionaries")
            processed_data = self._process_data(Data, filter_func, sort_key)
            if not processed_data:
                self.logger.warning("No discovered data to write after processing. Skipping file creation.")
                return
            if filename is None:
                filename = self._get_user_filename(self.default_name_pdf, '.pdf', interactive)
            filename = self._get_unique_filename(filename, output_dir)

            self.logger.info("Writing data to PDF file...")
            doc = SimpleDocTemplate(filename, pagesize=letter)
            styles = getSampleStyleSheet()
            elements = []

            # Metadata
            elements.append(Paragraph("Report", styles['Title']))
            elements.append(Spacer(1, 12))
            elements.append(Paragraph(f"Generated on: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", styles['Normal']))
            elements.append(Paragraph(f"Generated by: {os.getlogin()}", styles['Normal']))
            elements.append(Paragraph(f"Hostname: {platform.node() or 'Unknown'}", styles['Normal']))
            elements.append(Paragraph(f"OS: {platform.system()} {platform.release() or 'Unknown'}", styles['Normal']))
            if custom_metadata:
                for key, value in custom_metadata.items():
                    elements.append(Paragraph(f"{key}: {value}", styles['Normal']))
            elements.append(Spacer(1, 12))

            # Data Table
            all_fieldnames = sorted(set().union(*(fdata.keys() for fdata in processed_data)))
            table_data = [all_fieldnames]
            for fdata in processed_data:
                table_data.append([str(fdata.get(key, '')) for key in all_fieldnames])
            table = Table(table_data)
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            elements.append(table)

            doc.build(elements)
            self.logger.info("Data writing completed.")

            full_path = os.path.abspath(filename)
            self.logger.info(f"Report generated successfully in PDF format: {filename}")
            self.logger.info(f"Total records written: {len(processed_data)}")
            self.logger.info(f"Path of {filename}: {full_path}")

        except Exception as e:
            self.logger.error(f"Error generating PDF report: {e}")
            self.logger.error(f"Detailed Error: {e.__class__.__name__} - {e}")

if __name__ == "__main__":
    # Example usage
    generator = Report_Generator()
    sample_data = [{"Name": "John", "Age": 30}, {"Name": "Jane", "Age": 25}]
    custom_metadata = {"Project": "ReportRiser", "Version": "1.0"}
    generator.CSV_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
    generator.TXT_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
    generator.JSON_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
    generator.XML_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
    generator.HTML_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
    generator.MD_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
    generator.PDF_GenerateReport(sample_data, interactive=False, custom_metadata=custom_metadata)
